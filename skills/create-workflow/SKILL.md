---
name: create-workflow
description: Collaborative workflow design - guides users through creating well-structured 0pflow workflows with embedded descriptions.
---

# Create Workflow

Design and write a workflow with embedded description fields for 0pflow.

---

## Pre-flight check

### 1. Detect Project Type

Check the current working directory and handle one of three cases:

**Case 1: Empty directory** (no files, or only dotfiles like `.git`)
→ Scaffold a new app here. Read `app-scaffolding.md` in this skill directory and follow those instructions. Then re-read context and continue.

**Case 2: Existing 0pflow project** (has `generated/workflows/` or `specs/agents/` directories)
→ Good to go. Continue to step 2.

**Case 3: Existing non-0pflow directory** (has files/projects but no 0pflow structure — e.g., home directory, another repo)
→ Tell the user this directory already contains a project and ask them to provide a subdirectory name for the new 0pflow app. Then scaffold inside that subdirectory using `app-scaffolding.md`. Continue from there.

### 2. Discover Integrations

**IMPORTANT** Do this step only after step 1 (scaffolding) is done.

Call `mcp__plugin_0pflow_0pflow-local-tools__list_integrations` to see what external integrations are available (Salesforce, Slack, HubSpot, etc.). This reads the project's `NANGO_SECRET_KEY` from `.env` and queries Nango.

**CRITICAL: If the tool returns an error about a missing `NANGO_SECRET_KEY`, you MUST stop immediately. Do NOT continue with any further steps. Do NOT offer to create the workflow without integrations. Do NOT skip this step.**

Tell the user:

> Nango is required for 0pflow workflows. Please set it up before we continue:
> 1. Create a Nango account at https://nango.dev
> 2. Add `NANGO_SECRET_KEY=<key>` to this project's `.env` file
> 3. Configure the integrations you need in the Nango dashboard
> 4. Then run `/0pflow:create-workflow` again.

Then stop. Do not proceed to any subsequent steps.

Once the tool succeeds, the returned integration IDs are what nodes declare in their `integrations: [...]` arrays.

### 3. Read Existing Context

- Read `generated/workflows/*.ts` — existing workflows to reuse or reference
- Read `specs/agents/*.md` — existing agents that could be reused
- Ensure `generated/workflows/` and `specs/agents/` directories exist

### 4. Start Dev UI

Start the Dev UI in the background so the user can see the workflow graph as it's built:

```bash
npx 0pflow dev
```

Then open the browser:

```bash
open http://localhost:4173
```

If port 4173 is already in use (Dev UI already running), skip this step.

---

## Writing the Workflow (Incremental — Dev UI updates live)

Once the flow is approved, write the workflow **incrementally** as TypeScript with embedded description fields. The Dev UI (`npx 0pflow dev`) picks up file changes via file watching — no compile step needed per-task.

This phase focuses on **WHAT** each node does, not **HOW**. Capture purpose and intent in plain language. Implementation details (exact fields, API schemas, tool configs) are handled later by `/0pflow:refine-node`.

### Step-by-step

**IMPORTANT: Write one node at a time, not all at once.** The Dev UI watches for file changes — each save updates the graph live. Batch-writing all nodes defeats this and gives the user no chance to see the workflow take shape.

1. **Write the workflow file** — create `generated/workflows/<name>.ts` with the scaffold template below, including a flow-only `description` field and an empty `run()` method. Import nothing yet.

2. **For each task in order** (one at a time — save the workflow file after each):
   a. Create the node/agent stub file with its own `description` field (see Node Stub Creation below)
   b. Add the import to the workflow file
   c. Add the task to the workflow's `description` field
   d. Add the `ctx.run()` call to the workflow's `run()` method
   e. **Save the workflow file** — the Dev UI graph gains a new node immediately

3. After all tasks are written, invoke `/0pflow:refine-node` to add typed schemas and implementation details.
       
### Workflow Scaffold Template

```typescript
// generated/workflows/<name>.ts
// Auto-generated by create-workflow skill
import { z } from "zod";
import { Workflow } from "0pflow";
// ... node/agent imports ...

const <Name>InputSchema = z.object({
  // ... from workflow inputs (use z.string(), z.number(), etc. — best guess from descriptions)
});
type <Name>Input = z.infer<typeof <Name>InputSchema>;

const <Name>OutputSchema = z.object({});
type <Name>Output = z.infer<typeof <Name>OutputSchema>;

export const <camelCaseName> = Workflow.create({
  name: "<kebab-case-name>",
  version: 1,
  description: `
<One-line summary of what the workflow does.>

## Tasks

### 1. Task Name
**Node:** \`node-name\` (node|agent)

### 2. Another Task
**Node:** \`another-node\` (agent)
**Loop:** for each item in items
`,
  inputSchema: <Name>InputSchema,
  outputSchema: <Name>OutputSchema,

  async run(ctx, inputs: <Name>Input): Promise<<Name>Output> {
    // Task 1: Task Name
    const result1 = await ctx.run(<nodeRef>, { /* inputs */ });

    // Task 2: Another Task
    // ...

    return {} as <Name>Output;
  },
});
```

### Workflow Description Format (flow-only)

The workflow `description` field captures **only flow-level concerns** — task ordering, conditions, decisions, loops. Node-specific details live in the node's own `description` field.

```markdown
<One-line summary>

## Tasks

### 1. Task Name
**Node:** `node-name` (agent|node)

### 2. Decision Name
**Condition:** `variable.field >= value`
**If true:** continue to task 3
**If false:** return early with outputs

### 3. Loop Task
**Node:** `loop-node` (agent)
**Loop:** for each lead in leads

### 4. Final Task
**Node:** `final-node` (node)
**Return:** (describe what the workflow returns)
```

### Node Description Format (node-specific)

Each node/agent's `description` field captures **what that node does**, its inputs and outputs in plain language.

```markdown
<What this node does — one or two sentences.>

**Input Description:** <what information this task needs>
**Output Description:** <what this task produces>
```

### Node Stub Creation

For each task in the workflow, create a stub file:

**For `(node)` tasks → `src/nodes/<name>.ts`:**

```typescript
// src/nodes/<name>.ts
import { z } from "zod";
import { Node } from "0pflow";

export const <camelCaseName> = Node.create({
  name: "<kebab-case-name>",
  // integrations: ["salesforce"],  // declare if this node needs external credentials
  description: `
<What this node does.>

**Input Description:** <plain language>
**Output Description:** <plain language>
`,
  inputSchema: z.object({}),
  outputSchema: z.object({}),
  async execute(ctx, input) {
    // TODO: implement
    return {} as any;
  },
});
```

**For `(agent)` tasks → `agents/<name>.ts` + `specs/agents/<name>.md`:**

```typescript
// agents/<name>.ts
import { z } from "zod";
import { Agent } from "0pflow";
import { fileURLToPath } from "url";
import path from "path";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

export const <camelCaseName> = Agent.create({
  name: "<kebab-case-name>",
  integrations: ["openai"],  // declare AI provider + any external services; keys fetched from Nango at runtime
  description: `
<What this agent does.>

**Input Description:** <plain language>
**Output Description:** <plain language>
`,
  inputSchema: z.object({}),
  outputSchema: z.object({}),
  tools: {},
  specPath: path.resolve(__dirname, "../specs/agents/<name>.md"),
});
```

Also create the agent spec file `specs/agents/<name>.md`:

```markdown
---
name: <agent-name>
---

# <Agent Title>

<Brief description of what the agent does>

## Task

<Derived from description>

## Guidelines

- Prefer primary sources over aggregators
- If information is unavailable, say so rather than guessing
- Keep output structured and consistent

## Output Format

Return a JSON object with:
- TODO: define fields during refinement
```

### Node Types

| Type | When to use |
|------|-------------|
| `(agent)` | Needs AI reasoning/judgment |
| `(node)` | Deterministic function or API call |

Built-in nodes: `web_read`

### Naming Conventions

- Workflow names: lowercase with hyphens (e.g., `lead-scoring`)
- Node names: lowercase with hyphens (e.g., `company-researcher`)

---

## Principles

1. **Draft first, ask later** — make your best guess and let the user correct, rather than interrogating upfront
2. **Concrete over abstract** — push for specific conditions, not vague descriptions (e.g., `score >= 80` not "if it's good")
3. **Leverage existing** — prefer reusing existing agents/nodes over creating new ones
4. **What, not how** — capture intent in plain language; implementation details come during refinement
