---
name: create-workflow
description: Collaborative workflow design - guides users through creating well-structured 0pflow workflows with embedded descriptions.
---

# Create Workflow

Design and write a workflow with embedded description fields for 0pflow.

---

## Context Gathering (do silently)

Before drafting, gather context without reporting it to the user:

### 1. Detect Project Type

Check the current working directory and handle one of three cases:

**Case 1: Empty directory** (no files, or only dotfiles like `.git`)
→ Scaffold a new app here. Read `app-scaffolding.md` in this skill directory and follow those instructions. Then re-read context and continue.

**Case 2: Existing 0pflow project** (has `generated/workflows/` or `specs/agents/` directories)
→ Good to go. Continue to step 2.

**Case 3: Existing non-0pflow directory** (has files/projects but no 0pflow structure — e.g., home directory, another repo)
→ Tell the user this directory already contains a project and ask them to provide a subdirectory name for the new 0pflow app. Then scaffold inside that subdirectory using `app-scaffolding.md`. Continue from there.

### 2. Discover Integrations

Call `mcp__plugin_0pflow_0pflow__list_integrations` to see what external systems are available (Slack, Salesforce, etc.).

### 3. Read Existing Context

- Read `generated/workflows/*.ts` — existing workflows to reuse or reference
- Read `specs/agents/*.md` — existing agents that could be reused
- Ensure `generated/workflows/` and `specs/agents/` directories exist

### 4. Start Dev UI

Start the Dev UI in the background so the user can see the workflow graph as it's built:

```bash
npx 0pflow dev &
```

Then open the browser:

```bash
open http://localhost:4173
```

If port 4173 is already in use (Dev UI already running), skip this step.

---

## Designing the Workflow

Based on the user's description and the context you gathered, **draft a complete workflow design**. Use your judgment to fill in reasonable defaults. Only ask clarifying questions if something is genuinely ambiguous — prefer making a good guess and letting the user correct it.

Think through:
- **Trigger:** What starts the workflow? (webhook, manual input, schedule)
- **Tasks:** What steps are needed? In what order?
- **Decisions:** Are there branching points? What are the conditions?
- **Node types:** Does each task need AI judgment (agent) or is it a function/API call (node)?
- **Existing nodes:** Can any existing agents or built-in nodes (`web_read`, etc.) be reused?
- **Integrations:** Do any connected integrations apply?

### Present an ASCII Diagram

Present the workflow as an ASCII diagram for the user to review:

```
┌─────────────┐
│   Trigger   │
│ (inputs)    │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│  Task 1     │
│ node-name   │
└──────┬──────┘
       │
       ▼
   ◇ Decision?
  ╱           ╲
YES             NO
 │               │
 ▼               ▼
┌─────┐      ┌──────┐
│Task2│      │Return│
└──┬──┘      └──────┘
   │
   ▼
┌─────────────┐
│   Return    │
└─────────────┘
```

Use boxes for tasks, diamonds for decisions, arrows for flow. Adapt to the actual workflow.

Ask: **"Does this flow look right?"**

Iterate on the diagram based on feedback until the user is happy.

---

## Writing the Workflow (Incremental — Dev UI updates live)

Once the flow is approved, write the workflow **incrementally** as TypeScript with embedded description fields. The Dev UI (`npx 0pflow dev`) picks up file changes via file watching — no compile step needed per-task.

This phase focuses on **WHAT** each node does, not **HOW**. Capture purpose and intent in plain language. Implementation details (exact fields, API schemas, tool configs) are handled later by `/0pflow:refine-node`.

### Step-by-step

1. **Write the workflow file** — create `generated/workflows/<name>.ts` with the scaffold template below, including a flow-only `description` field and an empty `run()` method.

2. **For each task in order:**
   a. Add the task to the workflow's `description` field
   b. Create the node/agent stub file with its own `description` field (see Node Stub Creation below)
   c. Add the `ctx.run()` call to the workflow's `run()` method — the Dev UI graph gains a new node immediately

3. After all tasks are written, invoke `/0pflow:refine-node` to add typed schemas and implementation details.

### Workflow Scaffold Template

```typescript
// generated/workflows/<name>.ts
// Auto-generated by create-workflow skill
import { z } from "zod";
import { Workflow } from "0pflow";
// ... node/agent imports ...

const <Name>InputSchema = z.object({
  // ... from workflow inputs (use z.string(), z.number(), etc. — best guess from descriptions)
});
type <Name>Input = z.infer<typeof <Name>InputSchema>;

const <Name>OutputSchema = z.object({});
type <Name>Output = z.infer<typeof <Name>OutputSchema>;

export const <camelCaseName> = Workflow.create({
  name: "<kebab-case-name>",
  version: 1,
  description: `
<One-line summary of what the workflow does.>

## Tasks

### 1. Task Name
**Node:** \`node-name\` (node|agent)

### 2. Another Task
**Node:** \`another-node\` (agent)
**Loop:** for each item in items
`,
  inputSchema: <Name>InputSchema,
  outputSchema: <Name>OutputSchema,

  async run(ctx, inputs: <Name>Input): Promise<<Name>Output> {
    // Task 1: Task Name
    const result1 = await ctx.run(<nodeRef>, { /* inputs */ });

    // Task 2: Another Task
    // ...

    return {} as <Name>Output;
  },
});
```

### Workflow Description Format (flow-only)

The workflow `description` field captures **only flow-level concerns** — task ordering, conditions, decisions, loops. Node-specific details live in the node's own `description` field.

```markdown
<One-line summary>

## Tasks

### 1. Task Name
**Node:** `node-name` (agent|node)

### 2. Decision Name
**Condition:** `variable.field >= value`
**If true:** continue to task 3
**If false:** return early with outputs

### 3. Loop Task
**Node:** `loop-node` (agent)
**Loop:** for each lead in leads

### 4. Final Task
**Node:** `final-node` (node)
**Return:** (describe what the workflow returns)
```

### Node Description Format (node-specific)

Each node/agent's `description` field captures **what that node does**, its inputs and outputs in plain language.

```markdown
<What this node does — one or two sentences.>

**Input Description:** <what information this task needs>
**Output Description:** <what this task produces>
```

### Node Stub Creation

For each task in the workflow, create a stub file:

**For `(node)` tasks → `src/nodes/<name>.ts`:**

```typescript
// src/nodes/<name>.ts
import { z } from "zod";
import { Node } from "0pflow";

export const <camelCaseName> = Node.create({
  name: "<kebab-case-name>",
  description: `
<What this node does.>

**Input Description:** <plain language>
**Output Description:** <plain language>
`,
  inputSchema: z.object({}),
  outputSchema: z.object({}),
  async run(ctx, input) {
    // TODO: implement
    return {} as any;
  },
});
```

**For `(agent)` tasks → `agents/<name>.ts` + `specs/agents/<name>.md`:**

```typescript
// agents/<name>.ts
import { z } from "zod";
import { Agent } from "0pflow";
import { fileURLToPath } from "url";
import path from "path";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

export const <camelCaseName> = Agent.create({
  name: "<kebab-case-name>",
  description: `
<What this agent does.>

**Input Description:** <plain language>
**Output Description:** <plain language>
`,
  inputSchema: z.object({}),
  outputSchema: z.object({}),
  tools: {},
  specPath: path.resolve(__dirname, "../specs/agents/<name>.md"),
});
```

Also create the agent spec file `specs/agents/<name>.md`:

```markdown
---
name: <agent-name>
---

# <Agent Title>

<Brief description of what the agent does>

## Task

<Derived from description>

## Guidelines

- Prefer primary sources over aggregators
- If information is unavailable, say so rather than guessing
- Keep output structured and consistent

## Output Format

Return a JSON object with:
- TODO: define fields during refinement
```

### Node Types

| Type | When to use |
|------|-------------|
| `(agent)` | Needs AI reasoning/judgment |
| `(node)` | Deterministic function or API call |

Built-in nodes: `web_read`

### Naming Conventions

- Workflow names: lowercase with hyphens (e.g., `lead-scoring`)
- Node names: lowercase with hyphens (e.g., `company-researcher`)

---

## Principles

1. **Draft first, ask later** — make your best guess and let the user correct, rather than interrogating upfront
2. **Concrete over abstract** — push for specific conditions, not vague descriptions (e.g., `score >= 80` not "if it's good")
3. **Leverage existing** — prefer reusing existing agents/nodes over creating new ones
4. **What, not how** — capture intent in plain language; implementation details come during refinement
