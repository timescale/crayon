// packages/core/src/registry-gen.ts
// Generates generated/registry.ts with static imports for all workflows, agents, and nodes.
// This replaces runtime discover() for bundled environments (Next.js, etc.).

import fs from "node:fs";
import path from "node:path";

interface RegistryEntry {
  /** Variable name used in import statement (e.g., "urlCheck") */
  importName: string;
  /** Executable name from the name: field (e.g., "url-check") */
  executableName: string;
  /** Import path relative to generated/registry.ts */
  importPath: string;
}

/**
 * Scan a directory for .ts/.js files and extract exported executable info.
 * Looks for patterns like: export const foo = Workflow.create({ name: "foo-bar", ... })
 */
function scanDirectory(dir: string): RegistryEntry[] {
  if (!fs.existsSync(dir)) return [];

  const files = fs
    .readdirSync(dir)
    .filter((f) => (f.endsWith(".ts") || f.endsWith(".js")) && f !== "index.ts" && f !== "index.js");

  const entries: RegistryEntry[] = [];

  for (const file of files) {
    const filePath = path.join(dir, file);
    const content = fs.readFileSync(filePath, "utf-8");

    // Match: export const <name> = (Workflow|Agent|Node).create({
    const exportMatch = content.match(
      /export\s+const\s+(\w+)\s*=\s*(?:Workflow|Agent|Node)\.create\s*\(/,
    );
    if (!exportMatch) continue;

    const importName = exportMatch[1];

    // Match: name: "some-name" or name: 'some-name'
    const nameMatch = content.match(/name:\s*["']([^"']+)["']/);
    if (!nameMatch) continue;

    entries.push({
      importName,
      executableName: nameMatch[1],
      importPath: "", // filled in by caller
    });
  }

  return entries;
}

/**
 * Generate the registry.ts file content
 */
function buildRegistrySource(
  workflows: RegistryEntry[],
  agents: RegistryEntry[],
  nodes: RegistryEntry[],
): string {
  const lines: string[] = [
    "// generated/registry.ts",
    "// Auto-generated by crayon build - do not edit directly",
    "",
  ];

  // Import statements
  for (const entry of [...workflows, ...agents, ...nodes]) {
    lines.push(
      `import { ${entry.importName} } from "${entry.importPath}";`,
    );
  }

  lines.push("");

  // Workflow record
  lines.push("export const workflows = {");
  for (const entry of workflows) {
    lines.push(`  "${entry.executableName}": ${entry.importName},`);
  }
  lines.push("};");
  lines.push("");

  // Agent record
  lines.push("export const agents = {");
  for (const entry of agents) {
    lines.push(`  "${entry.executableName}": ${entry.importName},`);
  }
  lines.push("};");
  lines.push("");

  // Node record
  lines.push("export const nodes = {");
  for (const entry of nodes) {
    lines.push(`  "${entry.executableName}": ${entry.importName},`);
  }
  lines.push("};");
  lines.push("");

  return lines.join("\n");
}

/**
 * Generate generated/registry.ts with static imports for all executables.
 * Call this during build (e.g., `crayon build` or as a prebuild script).
 */
export function generateRegistry(projectDir: string): string {
  const workflowDir = path.join(projectDir, "generated", "workflows");
  const agentsDir = path.join(projectDir, "agents");

  // Support both src/nodes/ and nodes/ layouts
  const srcNodesDir = path.join(projectDir, "src", "nodes");
  const rootNodesDir = path.join(projectDir, "nodes");
  const nodesDir = fs.existsSync(srcNodesDir) ? srcNodesDir : rootNodesDir;
  const nodesRelative = fs.existsSync(srcNodesDir) ? "../src/nodes" : "../nodes";

  // Scan each directory
  const workflows = scanDirectory(workflowDir);
  const agents = scanDirectory(agentsDir);
  const nodes = scanDirectory(nodesDir);

  // Set import paths relative to generated/registry.ts
  // Use actual file extensions (not .js) for bundler compatibility (Turbopack, etc.)
  for (const entry of workflows) {
    entry.importPath = `./workflows/${toSourceFilename(workflowDir, entry)}`;
  }
  for (const entry of agents) {
    entry.importPath = `../agents/${toSourceFilename(agentsDir, entry)}`;
  }
  for (const entry of nodes) {
    entry.importPath = `${nodesRelative}/${toSourceFilename(nodesDir, entry)}`;
  }

  const source = buildRegistrySource(workflows, agents, nodes);

  // Strip .js extensions from imports in generated workflow files
  // (Turbopack can't resolve .js → .ts in production builds)
  stripJsExtensionsInDir(workflowDir);

  // Write the file
  const outDir = path.join(projectDir, "generated");
  if (!fs.existsSync(outDir)) {
    fs.mkdirSync(outDir, { recursive: true });
  }
  const outPath = path.join(outDir, "registry.ts");
  fs.writeFileSync(outPath, source);

  return outPath;
}

/**
 * Strip .js extensions from relative imports in all .ts files in a directory.
 * Turbopack can't resolve .js → .ts in production builds.
 */
function stripJsExtensionsInDir(dir: string): void {
  if (!fs.existsSync(dir)) return;

  for (const file of fs.readdirSync(dir).filter((f) => f.endsWith(".ts"))) {
    const filePath = path.join(dir, file);
    const content = fs.readFileSync(filePath, "utf-8");
    // Replace .js extension in relative imports: from "../../foo.js" → from "../../foo"
    const updated = content.replace(
      /(from\s+["']\.\.?\/[^"']*?)\.js(["'])/g,
      "$1$2",
    );
    if (updated !== content) {
      fs.writeFileSync(filePath, updated);
    }
  }
}

/**
 * Find the source filename (without extension) for a registry entry
 */
function toSourceFilename(dir: string, entry: RegistryEntry): string {
  // Find the actual file that contains this export (returns basename without extension)
  const files = fs.readdirSync(dir).filter((f) => f.endsWith(".ts") || f.endsWith(".js"));
  for (const file of files) {
    const content = fs.readFileSync(path.join(dir, file), "utf-8");
    if (content.includes(`export const ${entry.importName}`)) {
      return file.replace(/\.(ts|js)$/, "");
    }
  }
  // Fallback: derive from executable name
  return entry.executableName;
}
